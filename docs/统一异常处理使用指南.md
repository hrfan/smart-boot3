# 统一异常处理使用指南

## 概述

本项目实现了统一的异常处理机制，包括：

1. **统一的异常类体系** - 基于 `BaseBusinessException` 的业务异常类
2. **统一的响应格式** - 使用 `Result<T>` 类标准化API响应
3. **全局异常处理器** - `GlobalExceptionHandler` 统一处理各种异常
4. **Spring Security 集成** - 解决 Spring Security 覆盖正常错误提示的问题

## 异常类体系

### 基础异常类

- `BaseBusinessException` - 业务异常基类
- `ParameterValidationException` - 参数验证异常
- `BusinessLogicException` - 业务逻辑异常
- `DataAccessException` - 数据访问异常

### 异常工具类

`ExceptionUtil` 提供便捷的异常抛出方法：

```java
// 抛出业务异常
ExceptionUtil.throwBusinessError("业务处理失败");

// 抛出参数验证异常
ExceptionUtil.throwParameterError("参数验证失败");

// 抛出数据不存在异常
ExceptionUtil.throwDataNotFound("用户不存在");

// 抛出数据已存在异常
ExceptionUtil.throwDataAlreadyExists("用户名已存在");

// 抛出操作不允许异常
ExceptionUtil.throwOperationNotAllowed("当前状态不允许此操作");
```

## 全局异常处理器

`GlobalExceptionHandler` 使用 `@RestControllerAdvice` 注解，统一处理以下异常：

### 业务异常
- `BaseBusinessException` - 返回业务错误码和消息

### 参数验证异常
- `MethodArgumentNotValidException` - @Valid 注解验证失败
- `BindException` - @Validated 注解验证失败
- `ConstraintViolationException` - 方法参数验证失败
- `MissingServletRequestParameterException` - 缺少请求参数
- `MethodArgumentTypeMismatchException` - 参数类型不匹配

### HTTP异常
- `HttpRequestMethodNotSupportedException` - 不支持的HTTP方法
- `NoHandlerFoundException` - 404异常

### Spring Security异常
- `AuthenticationException` - 认证异常
- `AccessDeniedException` - 访问拒绝异常

### 系统异常
- `SQLException` - 数据库异常
- `java.nio.file.AccessDeniedException` - 文件访问拒绝异常
- `Exception` - 其他未捕获异常

## 统一响应格式

所有异常都返回统一的 `Result<T>` 格式：

```json
{
  "success": false,
  "code": 1000,
  "message": "业务处理失败",
  "data": null,
  "timestamp": "2025-09-20 14:30:00",
  "error": true
}
```

## Spring Security 集成

### 问题解决

Spring Security 的异常处理器会覆盖我们的全局异常处理器。解决方案：

1. **更新认证入口点处理器** - `CustomAuthenticationEntryPoint` 使用统一的 `Result` 格式
2. **更新访问拒绝处理器** - `CustomAccessDeniedHandler` 使用统一的 `Result` 格式

### 配置说明

在 `SecurityConfig` 中配置公开路径：

```java
.requestMatchers("/api/public/**").permitAll()
```

## 使用示例

### 1. 在Controller中抛出业务异常

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public Result<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        if (user == null) {
            ExceptionUtil.throwDataNotFound("用户不存在");
        }
        return Result.success(user);
    }
}
```

### 2. 参数验证

```java
@PostMapping
public Result<User> createUser(@Valid @RequestBody CreateUserRequest request) {
    // 如果参数验证失败，会自动抛出 MethodArgumentNotValidException
    // 由 GlobalExceptionHandler 统一处理
    User user = userService.createUser(request);
    return Result.success(user);
}
```

### 3. 测试异常处理

访问测试接口：

```bash
# 测试成功响应
curl "http://localhost:9100/api/public/simple-test/success"

# 测试业务异常
curl "http://localhost:9100/api/public/simple-test/business-error"

# 测试数据不存在异常
curl "http://localhost:9100/api/public/simple-test/data-not-found"

# 测试系统异常
curl "http://localhost:9100/api/public/simple-test/system-error"
```

## 错误码说明

### HTTP状态码
- `200` - 成功
- `400` - 参数错误
- `401` - 未认证
- `403` - 访问被拒绝
- `404` - 资源不存在
- `405` - 方法不允许
- `500` - 服务器内部错误

### 业务错误码
- `1000` - 业务处理失败
- `1001` - 数据不存在
- `1002` - 数据已存在
- `1003` - 数据状态错误
- `1004` - 操作不允许
- `1005` - 资源不足
- `1006` - 配置错误
- `1007` - 网络错误
- `1008` - 第三方服务错误
- `1009` - 文件操作错误
- `1010` - 数据库操作失败
- `1011` - 缓存操作失败
- `1012` - 消息队列操作失败

## 最佳实践

1. **使用具体的异常类** - 不要直接抛出 `BaseBusinessException`，使用具体的子类
2. **提供有意义的错误信息** - 错误信息应该对用户友好
3. **记录异常日志** - 在业务代码中记录关键异常
4. **不要忽略异常** - 所有异常都应该被适当处理
5. **使用异常工具类** - 使用 `ExceptionUtil` 提供的方法抛出异常

## 扩展说明

### 添加新的异常类型

1. 继承 `BaseBusinessException`
2. 在 `ResultCode` 中添加对应的错误码
3. 在 `ExceptionUtil` 中添加便捷方法
4. 在 `GlobalExceptionHandler` 中添加处理逻辑（如果需要）

### 自定义异常处理

如果需要特殊处理某种异常，可以在 `GlobalExceptionHandler` 中添加新的 `@ExceptionHandler` 方法。

## 注意事项

1. 确保所有模块都依赖了 `smart-common-core` 模块
2. Spring Security 的异常处理器优先级更高，需要确保它们使用统一的响应格式
3. 异常处理器的顺序很重要，更具体的异常处理器应该放在前面
4. 在生产环境中，系统异常不应该暴露详细的错误信息给用户
